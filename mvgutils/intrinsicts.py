# AUTOGENERATED! DO NOT EDIT! File to edit: ../03_intrinsicts.ipynb.

# %% auto 0
__all__ = ['SUPPORTED_CAMERA_MODELS', 'to_homogeneous', 'from_homogeneous', 'Intrinsicts']

# %% ../03_intrinsicts.ipynb 3
import numpy as np
import cv2
from easydict import EasyDict as edict

# %% ../03_intrinsicts.ipynb 5
SUPPORTED_CAMERA_MODELS = dict(
    SIMPLE_PINHOLE = dict(id=0, n_params=3, params_str='f, cx, cy'), 
    PINHOLE        = dict(id=1, n_params=4,params_str='fx, fy, cx, cy'), 
    SIMPLE_RADIAL  = dict(id=2, n_params=4,params_str='f, cx, cy, k'), 
    RADIAL         = dict(id=3, n_params=5,params_str='f, cx, cy, k1, k2'), 
    OPENCV         = dict(id=4, n_params=8,params_str='fx, fy, cx, cy, k1, k2, p1, p2'), 
    OPENCV_FISHEYE = dict(id=5, n_params=8,params_str='fx, fy, cx, cy, k1, k2, k3, k4'), 
    FULL_OPENCV    = dict(id=6, n_params=12,params_str='fx, fy, cx, cy, k1, k2, p1, p2, k3, k4, k5, k6'), 
    FOV            = dict(id=7, n_params=5,params_str='fx, fy, cx, cy, omega'), 
    OPENCV5        = dict(id=-1, n_params=9,params_str='fx, fy, cx, cy, k1, k2, p1, p2, k3'),
    UNKNOWN        = dict(id=-1, n_params=0,params_str='[]'), 
)

def to_homogeneous(points):
    # from https://github.com/cvg/pixloc/blob/master/pixloc/pixlib/geometry/utils.py
    """Convert N-dimensional points to homogeneous coordinates.
    Args:
        points: torch.Tensor or numpy.ndarray with size (..., N).
    Returns:
        A torch.Tensor or numpy.ndarray with size (..., N+1).
    """
    # if isinstance(points, torch.Tensor):
    #     pad = points.new_ones(points.shape[:-1]+(1,))
    #     return torch.cat([points, pad], dim=-1)
    # elif isinstance(points, np.ndarray):
    pad = np.ones((points.shape[:-1]+(1,)), dtype=points.dtype)
    return np.concatenate([points, pad], axis=-1)
    # else:
    #     raise ValueError


def from_homogeneous(points):
    """Remove the homogeneous dimension of N-dimensional points.
    Args:
        points: torch.Tensor or numpy.ndarray with size (..., N+1).
    Returns:
        A torch.Tensor or numpy ndarray with size (..., N).
    """
    return points[..., :-1] / points[..., -1:]


# %% ../03_intrinsicts.ipynb 6
class Intrinsicts:
    'Camera intrinsic model'
    def __init__(self, 
                 camera_model_name: str,   # One of the keys in SUPPORTED_CAMERA_MODELS
                 width: int,               # width of the image in pixels
                 height: int,              # height of the image in pixels
                 params: list):            # parameters, in COLMAP conventions
        # prior_focal_length : 1 if we have confidence in the modelparameters and 0 if we do not trust the model parameters

        if camera_model_name not in SUPPORTED_CAMERA_MODELS:
            raise ValueError(f'Camera model ["{camera_model_name}"] not recognized as colmap camera model')
        
        param_names = SUPPORTED_CAMERA_MODELS[camera_model_name]['params_str'].split(',')
        param_names = [p.strip() for p in param_names]
        if len(param_names) != len(params):
            raise ValueError(f'{camera_model_name} expectes {len(param_names)} parameters but got {len(params)}') 

        self._w = width
        self._h = height

        self._camera_model_name = camera_model_name
        self._set_params(camera_model_name, params)

    @staticmethod
    def supported_camera_models():
        print('List of supported camera models and their parameters')
        print(55*'_')
        for m in SUPPORTED_CAMERA_MODELS:
            p = SUPPORTED_CAMERA_MODELS[m]['params_str']
            print(f'{m:20}: {p}')


    def __str__(self):
        s  = f'Camera: {self.camera_model_name}\n'
        s += f'  w,h={self.width,self.height}\n'
        s += f'  params: {self.get_params()}\n'
        s += f'  cx,cy= ({self.cx},{self.cy})\n'
        s += f'  fx,fy= ({self.fx},{self.fy})\n'
        s += f'  distortions: {self.distortions}\n'


        return s

    __repr__ = __str__

    @staticmethod
    def from_pinhole_model(fx: float,   # Focal length (x) in pixels
                           fy: float,   # Focal length (y) in pixels. fy might be equal to fx (SIMPLE_PINHOLE model) or different (PINHOLE model)
                           cx:float,    # Camera center (x) in pixels
                           cy: float,   # Camera center (y) in pixels
                           width: int,  # Image width in pixels
                           height: int  # Image height in pixels
                           ) -> 'Intrinsicts':
        'Contructing camera intrinsics model from opencv compatible data'
        if fx == fy:
            camera_model_name = 'SIMPLE_PINHOLE'
            params = [fx, cx, cy]
        else:
            camera_model_name = 'PINHOLE'
            params = [fx, fy, cx, cy]

        return Intrinsicts(camera_model_name,width, height, params)


    @staticmethod
    def from_opencv_model(K: np.ndarray, # 3x3 camera matrix
                          distortions: np.ndarray, # distortion array as produced by OpenCv
                          width: int, # Camera width in pixels
                          height: int # Camera height in pixels
                         ) -> 'Intrinsicts':
        'Contructing camera intrinsics model from opencv compatible data'
        if not isinstance(distortions, list):
            if len(distortions.shape) == 2:
                distortions = distortions.squeeze()
            distortions= distortions.tolist()
     
        fx = K[0,0]
        cx = K[0,2]
        fy = K[1,1]
        cy = K[1,2]

        params = [fx, fy, cx, cy]
        if len(distortions) == 4:
            camera_model_name = 'OPENCV'
            params += distortions
        elif len(distortions) == 5:
            camera_model_name = 'OPENCV5'
            params += distortions
        elif len(distortions) == 8:
            camera_model_name = 'FULL_OPENCV'
            params += distortions
        else:
            raise ValueError(f'Do not support opencv model with {len(distortions)} parameters')

        return Intrinsicts(camera_model_name,width, height, params)

    @staticmethod
    def from_opencv_fisheye_model(K: np.ndarray, # 3x3 camera matrix
                          distortions: np.ndarray, # distortion array for OpenCv fisheye model, should consist of 4 distrortion parameters
                          width: int, # Camera width in pixels
                          height: int # Camera height in pixels
                         ) -> 'Intrinsicts':
        'Contructing camera intrinsics model from data compatible with opencv fisheye model'
        if not isinstance(distortions, list):
            if len(distortions.shape) == 2:
                distortions = distortions.squeeze()
            distortions= distortions.tolist()
     
        fx = K[0,0]
        cx = K[0,2]
        fy = K[1,1]
        cy = K[1,2]

        params = [fx, fy, cx, cy]
        if len(distortions) == 4:
            camera_model_name = 'OPENCV'
            params += distortions
        else:
            raise ValueError(f'Do not support fisheye-opencv model with {len(distortions)} parameters')

        return Intrinsicts(camera_model_name,width, height, params)

    @staticmethod
    def from_test_model(as_full_opencv=False):
        'Contructing camera intrinsics model from opencv calibration tutorial'
        w, h = 640, 480 

        distortions = np.array(
            [
            [-2.6637260909660682e-01], 
            [-3.8588898922304653e-02], 
            [1.7831947042852964e-03], 
            [-2.8122100441115472e-04], 
            [2.3839153080878486e-01]
            ]
        )

        if as_full_opencv:
            distortions = np.array(
                [
                [-2.6637260909660682e-01], 
                [-3.8588898922304653e-02], 
                [1.7831947042852964e-03], 
                [-2.8122100441115472e-04], 
                [2.3839153080878486e-01],
                [0.0],
                [0.0],
                [0.0]
                ]
        )

        mtx = np.array(
            [
                [5.3591573396163199e+02, 0.,                     3.4228315473308373e+02],
                [0.,                     5.3591573396163199e+02, 2.3557082909788173e+02],
                [0.,                     0.,                     1.]
            ]
        )

        return Intrinsicts.from_opencv_model(mtx,distortions,w, h)

    @property
    def camera_model_name(self) -> str:
        'Returns the name of the camera model, e.g. `OPENCV`'
        return self._camera_model_name

    @property
    def fx(self):
        'Returns the (x) focal point in pixels'
        return self._K[0,0]

    @property
    def fy(self):
        'Returns the (y) forcal point in pixels'
        return self._K[1,1]

    @property
    def cx(self):
        'Returns the x coordinate of the camera center in pixels'
        return self._K[0,2]

    @property
    def cy(self):
        'Returns the y coordinate of the camera center in pixels'
        return self._K[1,2]

    @property
    def w(self):
        'Returns the width of image, same as calling to the `width` method'
        return self._w

    @property
    def width(self):
        'Returns the width of image, same as calling to the `w` method'
        return self._w

    @property
    def h(self):
        'Returns the height of image, same as calling to the `height` method'
        return self._h

    @property
    def height(self):
        'Returns the height of image, same as calling to the `h` method'
        return self._h

    def is_single_focal_lenght(self):
        return 'SIMPLE' in self.camera_model_name

    @property
    def K(self) -> np.ndarray:
        'Return the 4x4 camera matrix in homogenous coordinates'
        return self._K

    @property
    def K_inv(self) -> np.ndarray:
        'Return the 4x4 inverse of camera matrix in homogenous coordinates'
        return self._K_inv

    @property
    def K_3(self) -> np.ndarray:
        'Return the 3x3 camera matrix in npn homogenous coordinates'
        return self._K[:3,:3]

    @property
    def K_3_inv(self) -> np.ndarray:
        'Return the 3x3 inverse of the camera matrix in npn homogenous coordinates'
        return self._K_3_inv

    @property
    def distortions(self) -> np.ndarray:
        'Returns 1D distortion array'
        return self._distortions

    def get_fov(self) -> edict:
        'Get horizontal and vertical field of view of the canera, in degrees'
        # Zeliltsky 2.60
        fovx = 2 * np.rad2deg(np.arctan2(self.width , (2 * self.fx)))
        fovy = 2 * np.rad2deg(np.arctan2(self.height , (2 * self.fy)))

        return edict(fovx=fovx, fovy=fovy)


    def get_params(self) -> list:
        'Get list of parametes as expected in the consrtructor for the given camera model'
        if self.is_single_focal_lenght():
            cp = [self.fx, self.cx, self.cy]
        else:
            cp = [self.fx, self.fy, self.cx, self.cy]

        p = cp + [float(d) for d in self.distortions]
        return p
  
    def get_undistort_matrix(self, alpha=1.0):
        newcameramtx, roi = cv2.getOptimalNewCameraMatrix(self.K, self.distortions, (self.w,self.h), alpha, (self.w,self.h))
        return newcameramtx

    def _set_params(self, camera_model_name, params):
        param_names = SUPPORTED_CAMERA_MODELS[camera_model_name]['params_str'].split(',')
        param_names = [p.strip() for p in param_names]
        if len(param_names) != len(params):
            raise ValueError(f'{camera_model_name} expectes {len(param_names)} parameters but got {len(params)}') 

        self._params = params
        
        # First names should be one of f,fx,fy,cx,cy
        camera_matrix_components = ['f','fx','fy','cx','cy']
        dlist = []
        cp = edict(fx=0.,fy=0.,cx=0.,cy=0.)
        for i, (name, val) in enumerate(zip(param_names,params)):
#             print(name,val)
            if name not in camera_matrix_components:
                dlist.append(val)
            elif name == 'f': 
                cp.fx = val
                cp.fy = val
            else:
                cp[name] = val

        self._K = np.array(
            [
                [cp.fx, 0.0,     cp.cx,     0.0],
                [0.0,     cp.fy, cp.cy,     0.0],
                [0.0,     0.0,     1.0,     0.0 ],
                [0.0,     0.0,     0.0,     1.0 ]
            ]
        )
    
        self._K_inv = np.linalg.inv(self._K)
        self._K_3_inv = np.linalg.inv(self._K[:3,:3])

        self._distortions = np.array(dlist, dtype=np.float64)

    
    def _get_params_to_new_cx_cy_fx_fy(self, new_cx, new_cy, new_fx=None, new_fy=None):
        new_fx = self.fx if new_fx is None else new_fx
        new_fy = self.fy if new_fy is None else new_fy

        if self.is_single_focal_lenght():
            cp = [new_fx, new_cx, new_cy]
        else:
            cp =  [new_fx, new_fy, new_cx, new_cy]

        p = cp + [float(d) for d in self.distortions()]
        return p

    def crop_bbox(self, in_bbox, c_bbox, new_width, new_height):
        if in_bbox is None: return None

        if in_bbox.minx >= c_bbox.maxx or in_bbox.maxx <= c_bbox.minx: return None
        if in_bbox.miny >= c_bbox.maxy or in_bbox.maxy <= c_bbox.miny: return None

        b_xmin = max(in_bbox.minx - c_bbox.minx,0)
        b_xmax = min(max(in_bbox.maxx - c_bbox.minx,0), new_width)
        b_ymin = max(in_bbox.miny - c_bbox.miny,0)
        b_ymax = min(max(in_bbox.maxy - c_bbox.miny,0), new_height)
        if b_xmin == b_xmax or b_ymin == b_ymax: return None

        return edict(
            minx = b_xmin,
            maxx = b_xmax,
            miny = b_ymin,
            maxy = b_ymax
        )
    

    def resize(self, new_size):
        """Change camera intrinsicts due to image resize --> scale of focal lenghts
        Args:
            new_size (tuple): (destination_width, destination_height)
        """
        new_width = new_size[0]
        new_height = new_size[1]
        scale_w = new_width / self.width
        scale_h = new_height / self.height

        fx  = self.fx * scale_w    # fx
        cx  = self.cx * scale_w    # cx
        fy  = self.fy * scale_h    # fy
        cy  = self.cy * scale_h    # cy

        new_params = self._get_params_to_new_cx_cy_fx_fy(cx, cy, fx, fy)

        return Intrinsicts(
            camera_model_name=self.camera_model_name, 
            width=new_width, 
            height=new_height, 
            params=new_params
        )

    def crop(self, bbox, new_name=None):
        """Change camera intrinsicts due to clipping to a rectangular window --> shifting the proincipal point
        Args:
            min_crop_x (float): Minimal coordinate of clipping rectangle in x directior, in pixels
            min_crop_y ([float]): Minimal coordinate of clipping rectangle in y directior, in pixels
        """
        new_cx = self.cx -  int(round(bbox.minx))   # cx
        new_cy = self.cy - int(round(bbox.miny))   # cy

        new_width = bbox.maxx - bbox.minx
        new_height = bbox.maxy - bbox.miny

        new_params = self._get_params_to_new_cx_cy_fx_fy(new_cx, new_cy)

        return Intrinsicts(
            camera_model_name=self.camera_model_name, 
            width=new_width, 
            height=new_height, 
            params=new_params
        )

    def get_optimal_new_camera_matrix(self, alpha):
        """_summary_

        Args:
            alpha (float): A number between 0 and 1, If the value is 
               alpha = 0 --> when all the pixels in the undistorted image are valid
               alpha = 1 --> when all the source image pixels are retained in the undistorted image but with many black pixels 
            new_image_size (_type_, optional): _description_. Defaults to None.
        """
        # See cvGetOptimalNewCameraMatrix in line 2714 of https://github.com/opencv/opencv/blob/4.x/modules/calib3d/src/calibration.cpp
        # See https://docs.opencv.org/3.3.0/dc/dbb/tutorial_py_calibration.html

        outer, inner = self.icv_get_rectangles()

        new_image_width = self.width
        new_image_height = self.height
   
        # Projection mapping inner rectangle to viewport
        fx0 = (new_image_width-1)/ inner.width
        fy0 = (new_image_height-1)/ inner.height
        cx0 = -fx0 * inner.x
        cy0 = -fy0 * inner.y

        # Projection mapping outer rectangle to viewport
        fx1 = (new_image_width-1)/ outer.width
        fy1 = (new_image_height-1)/ outer.height
        cx1 = -fx1 * outer.x
        cy1 = -fy1 * outer.y

        # Interpolate between the two optimal projections
        fx = fx0*(1 - alpha) + fx1*alpha
        fy = fy0*(1 - alpha) + fy1*alpha
        cx = cx0*(1 - alpha) + cx1*alpha
        cy = cy0*(1 - alpha) + cy1*alpha

        new_params = [fx,fy,cx,cy]
        return Intrinsicts(
            camera_model_name='PINHOLE', 
            width=new_image_width, 
            height=new_image_height, 
            params=new_params
        )

    #---------------------------------------------------------------------------
    # project and unproject points functions:
    #---------------------------------------------------------------------------
    # camera2image_points
    def camera2image_points(
        self, 
        pc3d: np.ndarray                                   # 3D points in camera frame system with shape (N,3)
        ) -> Tuple[np.ndarray, np.ndarray, np.ndarray] :   # A 2D point in the camera plane with shape (N,2), disparities with shape (N,1) and boolean valid mask with shape (N,)
        'Project 3D points in the camera reference coordinate system into image coordinates'

        assert(pc3d.shape[-1] == 3)

        p_camera_plane_distorted, disparity, valid = self.project_and_distort_points(pc3d)
        p_image = self.to_image_points(p_camera_plane_distorted)
        return p_image, disparity, valid

    def project_and_distort_points(
        self, 
        pc3d: np.ndarray                                   # 3D points in camera frame system with shape (N,3)
        ) -> Tuple[np.ndarray, np.ndarray, np.ndarray] :   # A 2D point in the camera plane with shape (N,2), disparities with shape (N,1) and boolean valid mask with shape (N,)
        'Project 3D points in the camera reference coordinate system into 2D distorted points in the camera frame'

        # project to camera plane (undistorted). Not used when we use OpenCV functions ProjectPoints since they project and undistort 
        # in a single function call
        p_camera_plane_undistorted, disparity, valid = self.project_points(pc3d)

        if self.camera_model_name in ['OPENCV', 'FULL_OPENCV']:
            no_rot = np.array([[0.0], [0.0], [0.0]])
            no_trans = np.array([[0.0], [0.0], [0.0]])
            K = np.eye(3)
            pimage_cv, _ =  cv2.projectPoints(
                pc3d,                              # project to image
                no_rot,
                no_trans,
                K,
                self.distortions)
            p_camera_plane_distorted = pimage_cv.squeeze(1)
        elif self.camera_model_name ==  'OPENCV_FISHEYE':
            no_rot = np.array([[0.0], [0.0], [0.0]])
            no_trans = np.array([[0.0], [0.0], [0.0]])
            K = np.eye(3)
            p_camera_plane_distorted, _ =  cv2.fisheye.projectPoints(
                pc3d,                              # project to image
                no_rot,
                no_trans,
                K,
                self.distortions)
            p_camera_plane_distorted = pimage_cv.squeeze(1)
        else:
            p_camera_plane_distorted = self.distort_points(p_camera_plane_undistorted)    

        return p_camera_plane_distorted, disparity, valid

    def project_points(
        self, 
        pc3d: np.ndarray,                                  # 3D points in camera frame, with shape (N,3) 
        projection_type: str = 'perspective'     # Projection type
        ) -> Tuple[np.ndarray, np.ndarray, np.ndarray] :   # A 2D point in the camera plane with shape (N,2), disparities with shape (N,1) and boolean valid mask with shape (N,)
        'Project 3D points in camera frame to 2D points in the camera plane'
        eps = 1e-3

        z = pc3d[..., -1]
        valid = z > eps
        z = z.clip(min=eps)
        disparity = 1.0 / np.expand_dims(z,-1)
        p2d = pc3d[..., :-1] * disparity
        return p2d, disparity, valid

    def distort_points(
        self, 
        p_cam_undistorted: np.ndarray # 2D Undistorted point in the camera plane with shape (N,2)
        ) -> np.ndarray:              # 2D distorted point in the camera plane with shape (N,2)
        'Distort points in the camera plane'
        # see line 888 in https://github.com/colmap/colmap/blob/dev/src/base/camera_models.h
        camera_model_name = self.camera_model_name
        distortions = self.distortions
        if len(distortions) == 0:
            return  p_cam_distorted.copy()

        if self.camera_model_name in ['OPENCV', 'FULL_OPENCV','OPENCV_FISHEYE']:
            raise ValueError(f'Function distort_points can not be used for OpenCv models since the do projection and distortion in a single function call, thus require 3D points as input')
        elif camera_model_name == 'OPENCV5':
            # See https://learnopencv.com/understanding-lens-distortion/
            k1 = distortions[0]
            k2 = distortions[1]
            p1 = distortions[2]
            p2 = distortions[3] 
            k3 = distortions[4]

            xd, yd = p_cam_undistorted[..., 0], p_cam_undistorted[..., 1]

            x2 = xd*xd
            y2 = yd*yd
            xy = xd*yd
            r2 = x2 + y2
            r4 = r2*r2
            r6 = r2*r4

            a = 1.0 + k1*r2  + k2*r4 + k3*r6
            xu = a*xd + 2.0*p1*xy + p2*(r2 + 2.0*x2)
            yu = a*yd + p1*(r2+2.0*y2) + 2.0*p2*xy
    
            p_cam_distorted = np.stack([xu,yu], axis=-1)

            return p_cam_distorted
        else:
            raise ValueError(f'distort_points not impelmented for camera model [{self.camera_model_name}]')

    def to_image_points(
        self,
        pc_distorted: np.ndarray  # 2D points in the camera plane with shape (N,2)
        ) -> np.ndarray:          # 2D points in the image plane with shape (N,2)
        'Transform points from the camera plane to the image plane, using the camera matrix K'
 
        pcd_h = to_homogeneous(pc_distorted)
        pix_T = pcd_h @ self.K_3.T
        return pix_T[..., :-1]

    #----------------
    # image2camera
    #----------------
    def to_camera_points(
        self, 
        pu: np.ndarray,                  # points in image, shape is (N,2)
        disparity: np.ndarray = None,    # disparity of points, shape is (N,1). If None, disparity is not used
        ) -> np.ndarray: # points in distorted camera plane, shape (N,2)
        'Transform pixel image coordinates into the distorted camera plane'
        pu_h = to_homogeneous(pu)
        pd_h_T = pu_h @ self.K_3_inv.T
        pd = pd_h_T[..., :-1]          
        return pd 


    def project_camera_plane_to_3d(self, pc: np.array, disparity=None):
        """project a 3D vector
           See Szeliski, 2.1

        Args:
            pw (np.array): 4D vector of a world 3D point 
        """

        pc_3d = np.array([pc[0]/disparity, pc[1]/disparity,1./disparity,1])

        p_3d = np.linalg.inv(self.extrinsics) @ pc_3d

        return p_3d



    def undistort(self, pc_distorted: np.array):
        # see line 565 in https://github.com/colmap/colmap/blob/dev/src/base/camera_models.h
        eps = np.finfo(np.float64).eps
        N = pc_distorted.shape[0]

        kNumIterations = 17
        kMaxStepNorm = np.float32(1e-10)
        kRelStepSize = np.float32(1e-6)

        J = np.zeros((N,2,2))
        p0 = pc_distorted.copy()
        x = pc_distorted.copy()
        for i in range(kNumIterations):
            x0 = x[..., 0]
            x1 = x[..., 1]
            step0 = np.maximum(eps, kRelStepSize * x0)
            step1 = np.maximum(eps, kRelStepSize * x1)

            dx = self.distort_points(x)

            # Compute numerical Jacobian
            dx_0b = self.distort_points(np.array([x0 - step0, x1]).T)
            dx_0f = self.distort_points(np.array([x0 + step0, x1]).T)
            dx_1b = self.distort_points(np.array([x0        , x1 - step1]).T)
            dx_1f = self.distort_points(np.array([x0        , x1 + step1]).T)
            J[:,0, 0] = 1 + (dx_0f[...,0] - dx_0b[...,0]) / (2 * step0)
            J[:,0, 1] = (dx_1f[...,0] - dx_1b[...,0]) / (2 * step1)
            J[:,1, 0] = (dx_0f[...,1] - dx_0b[...,1]) / (2 * step0)
            J[:,1, 1] = 1 + (dx_1f[...,1] - dx_1b[...,1]) / (2 * step1)
    
            jac_invs = np.linalg.inv(J)
            for i in range(N):
                jinv = jac_invs[i,...]
                rhs = (dx - p0)[i,:]
                sx = jinv @ rhs
                x[i,:] -= sx
 

                                                    
        return  x   # undistorted




    def icv_get_rectangles(self):
        # see icvGetRectangles, line 2460 in https://github.com/opencv/opencv/blob/4.x/modules/calib3d/src/calibration.cpp
        N = 9
        x_step = self.w / (N-1)
        y_step = self.h / (N-1)

        # Get a grid over [w,h] image in original, distorted, coordinates
        xu = []
        yu = []
        xu_left = []
        xu_right = []
        yu_bottom = [] 
        yu_top = []         
        for y in range(N):
            yp = y*y_step
            for x in range(N):
                xp = x*x_step
                ps = np.array([xp,yp])
                pc_distorted = self.to_camera_points(ps)                # from 2d pixel coordinates to 2D camera plane
                pc_undistorted = self.undistort(pc_distorted)                              # undistors with inverse lens distortions

                x_undistorted = pc_undistorted[0]
                y_undistorted = pc_undistorted[1]

                xu.append(x_undistorted)
                yu.append(y_undistorted)
                if x == 0: xu_left.append(x_undistorted)
                if x == N-1: xu_right.append(x_undistorted)
                if y == 0: yu_top.append(y_undistorted)
                if y == N-1: yu_bottom.append(y_undistorted)


        xmin_o = np.min(xu)
        xmax_o = np.max(xu)
        ymin_o = np.min(yu)
        ymax_o = np.max(yu)
        outer = edict(x=xmin_o, y=ymin_o, width=xmax_o-xmin_o, height=ymax_o-ymin_o)


        xmin_i = np.max(xu_left)
        xmax_i = np.min(xu_right)
        ymin_i = np.max(yu_top)
        ymax_i = np.min(yu_bottom)
        inner = edict(x=xmin_i, y=ymin_i, width=xmax_i-xmin_i, height=ymax_i-ymin_i)

        return outer, inner


    def to_dict(self):
        return self.as_dict()

    def as_dict(self):
        asdict = dict(
            width=self.width,
            height=self.height,
            camera_model_name=self.camera_model_name,
            params=[float(p) for p in self.params.tolist()]
        )
        return asdict

#     def to_json(self, json_file):
#         write_json_file(self.as_dict(), json_file)

